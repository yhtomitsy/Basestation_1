//==================================================================================
// Verilog module generated by Clarity Designer    03/17/2019    11:26:36       
// Filename: csi2_4to1_1_cmos_2_dphy_ip.v                                                         
// Filename: 4:1 CSI-2 to CSI-2 1.1                                    
// Copyright(c) 2016 Lattice Semiconductor Corporation. All rights reserved.        
//==================================================================================
`timescale 1ns/1ps

module csi2_4to1_1_cmos_2_dphy_ip #(
////added support for HS_ONLY mode
  parameter CLK_MODE         = "HS_ONLY",
////added disable tinit count
  parameter TINIT_COUNT      = "ON",

  parameter  VC              = 2,           // 2-bit Virtual channel number
  parameter  WC              = 16'd36,	    // 16-bit Word Count in DPHY packet
  parameter  CRC16           = 1,           // Appends 16-bit checksum to the end of packet.  
                                            // 0 = off, 1 = on by default. CRC is always set to 1.
                                            // Turning off will append 16'hFFFF to end of packet.
  parameter  DATA_WIDTH      = 16,          // Internally used. Always set to 16.              
  parameter  TINIT_VALUE     = 1000,        // Specify time for the DPHY Tinit requirement. 
                                            // This is dependent on byte clock
  parameter  ROM_WAIT_TIME   = 200,         // Specify delay time for sending DCS commands. 
                                            // This is dependent on DCS clock.
  parameter  CN              = 5'b11100,    // Tx PLL Input Divider
                                            // (25 <= pix_clk/N <= 30)  
  parameter  CM              = 8'b11101110, // Tx PLL Feedback Divider
                                            // (640 <= (pix_clk/(N*O))*M) <= 1500)                 
  parameter  CO              = 2'b00,       // Tx PLL Output Divider
                                            // Refer to Mixel PLL Specs for valid values
  parameter  TX_FREQ_TGT     = 8'd112,      // Set the target Tx byte clock which is used by DPHY TX.
                                            // Setting this parameter does not mean that design will
                                            // output the specified byte clock. This is just used as a
                                            // reference value inside the design.											
  parameter	LANE_WIDTH       = 2,


  parameter	GEAR_16         = 0,            // 8:1 gearing

  parameter DSI_FORMAT      = 0,
  parameter EOTP            = 1'b0,
  parameter FILTER_1STLINE  = 0,

  parameter	DT              = 6'h2B,
  parameter	WORD_WIDTH      = 10,

// not available in CSI2 to CSI2 IP
// Used for debugging purposes. Used to set parameters for color bar generator.
  parameter TESTMODE        = 0
)
(
////added ports for handshaking between Rx/bridge and Tx
  input 		   clk_hs_en_i, // request LP->HS for clock lane
  input 		   d_hs_en_i, // request LP->HS for data lane
  output 		   d_hs_rdy_o, // data lane is in HS mode
  output wire 		   d_hs_en_o, // request LP->HS for data lane from pixel2byte
 // used by CSI2CSI
  output wire 		   ld_pyld_o,
  output wire              phdr_xfr_done_o,

  input 		   reset_n_i, // (active low) asynchronous reset
  input 		   pix_clk_i, // pixel clock

////Added separate port for Mixel PLL refclk, and Snow PLL lock
  input 		   ref_clk_i, // Mixel PLL refclk
  input 		   pll_lock_i, // Snow PLL lock
  
  output 		   byte_clk_o, // byte clock from DPHY
  output 		   pll_lock_o, // PLL clock lock signal
  output 		   tinit_done_o, // Tinit done
  
  input 		   core_clk_i, // core clock 
  input 		   pd_dphy_i, // DPHY PD signal

  input 		   sp_req_i, // Short packet request
  input 		   lp_req_i, // start trigger of line valid
  
  input [15:0] 		   wc_i, // Word count value
  input [1:0] 		   vc_i, // Virtual channel
  input [5:0] 		   dt_i, // data type
  
  input 		   byte_data_en_i,// Byte data enable input
  input [4*DATA_WIDTH-1:0] byte_data_i, // Byte data

  // DPHY Ports
  inout 		   clk_p_o,
  inout 		   clk_n_o,
  inout 		   d0_p_io,
  inout 		   d0_n_io,
  inout 		   d1_p_o,
  inout 		   d1_n_o,

// Debug ports
  output 		   c2d_ready_o,
  output 		   hs_clk_gate_en_o,
  output 		   hs_clk_en_o,
  output 		   lp_clk_en_o,
  output 		   dphy_pkten_o,
  output 		   byte_data_en_o					
);

//------------------------------------------------------------------------------
// WIRE DECLARATION
//------------------------------------------------------------------------------
wire [4*DATA_WIDTH-1:0]      byte_data_w;
wire [5:0]                   data_type_w;		
wire [15:0]                  chksum_w;
wire [4*DATA_WIDTH-1:0]      dphy_pkt_w;
wire [DATA_WIDTH-1:0]        hs_data_d3_w;
wire [DATA_WIDTH-1:0]        hs_data_d2_w;
wire [DATA_WIDTH-1:0]        hs_data_d1_w;
wire [DATA_WIDTH-1:0]        hs_data_d0_w;

wire                         vsync_w, vsync_gen_w;
wire                         hsync_w, hsync_gen_w;
wire                         de_w, de_gen_w;
wire [23:0]                  data_gen_w;
wire                         fv_w, fv_gen_w;
wire                         lv_w, lv_gen_w;

wire [WORD_WIDTH-1:0]        pixdata_d9_w;
wire [WORD_WIDTH-1:0]        pixdata_d8_w;
wire [WORD_WIDTH-1:0]        pixdata_d7_w;
wire [WORD_WIDTH-1:0]        pixdata_d6_w;
wire [WORD_WIDTH-1:0]        pixdata_d5_w;
wire [WORD_WIDTH-1:0]        pixdata_d4_w;
wire [WORD_WIDTH-1:0]        pixdata_d3_w;
wire [WORD_WIDTH-1:0]        pixdata_d2_w;
wire [WORD_WIDTH-1:0]        pixdata_d1_w;
wire [WORD_WIDTH-1:0]        pixdata_d0_w;

wire                         hs_clk_gate_en_w;
wire                         hs_clk_en_w;
wire                         lp_clk_en_w;
wire                         dphy_pkten_w;
wire                         byte_data_en_w;
wire                         vsync_start_w;
wire                         hsync_start_w;
wire                         fv_start_w;
wire                         lv_start_w;

wire                         start_ptrn_gen;  // Internally used to start pattern_gen module.
                                              // For debugging purposes only.
wire                         pix2byte_rstn_w;
wire [7:0]                   data_w;

wire                         odd_line_w;

wire [1:0]                   yuv420_wc;

wire                         c2d_ready_w;

// Wires for HS_DCS Support
wire done_dcs_crtl_w;
wire dphy_pkten_frmtr_w;
wire [4*DATA_WIDTH-1:0] dphy_pkt_frmtr_w;
wire done_w;


//prevents undeclared identifier compile error

// Mapping of data when HS_DCS is selected

////added wire to define start of LP->HS transition during HS_ONLY and HS_LP modes
wire clk_hs_en;

// Debug ports
assign hs_clk_gate_en_o = hs_clk_gate_en_w;
assign hs_clk_en_o      = hs_clk_en_w;
assign lp_clk_en_o      = lp_clk_en_w;
assign dphy_pkten_o     = dphy_pkten_w;
assign byte_data_en_o   = byte_data_en_w;

// Word count tracker for YUV420 data type for CSI2
// WC is twice for even lines compare to odd lines
assign yuv420_wc = (odd_line_w) ? 1 : 2;


///////////////////////////////////////////////////////////////
// Synchronize reset input to different clock domain
//////////////////////////////////////////////////////////////
////add reset for refclk
wire ref_rstn;
wire pix_rstn;
wire core_rstn;
csi2_4to1_1_synchronizer sync_u0 (.clk(core_clk_i), .rstn(reset_n_i), .in(reset_n_i & pll_lock_o), .out(core_rstn)); 
csi2_4to1_1_synchronizer sync_u1 (.clk(pix_clk_i), .rstn(reset_n_i), .in(reset_n_i), .out(pix_rstn)); 
////reset Mixel until Snow PLL lock is detected. If Snow PLL is not used, PLL lock input is tied to 1.
csi2_4to1_1_synchronizer sync_u2 (.clk(ref_clk_i), .rstn(reset_n_i), .in(reset_n_i & pll_lock_i), .out(ref_rstn));

// Data mapping for HS_DCS Support


// Debug ports


assign c2d_ready_o = (tinit_done_o) ? c2d_ready_w : tinit_done_o; 


///////////////////////////////////////////////////////////////
// packet header instance
///////////////////////////////////////////////////////////////
csi2_4to1_1_pkt_header_csi2_2bg pkt_header_csi2_2bg_inst (
  // clock and reset
  .core_rstn      (core_rstn),
  .core_clk_i     (core_clk_i),
  
  // packet settings
  .vc_i          (vc_i),
  .dt_i          (dt_i),
  .gear16_i      (GEAR_16),
  .wc_i          (wc_i),   

  // to bridge
  .ld_pyld_o     (ld_pyld_o),  

  // control/data from pixel2byte
  .sp_req_i      (sp_req_i),
  .lp_req_i      (lp_req_i), // from csi2csi arb

  //input from tx global
  .d_hs_rdy_i    (d_hs_rdy_o),
  
  .byte_data_i    (byte_data_i),
  .byte_data_en_i (byte_data_en_i),
  .phdr_xfr_done   (phdr_xfr_done_o),  
  .pix2byte_rstn_o (pix2byte_rstn_w),
  .dphy_pkt_o      (dphy_pkt_w),
  .dphy_pkten_o    (dphy_pkten_w)
);
 


///////////////////////////////////////////////////////////////
// tx_global_operation instance
///////////////////////////////////////////////////////////////
generate 
  if (CLK_MODE=="HS_ONLY") begin: gen_clk_hs_en_hs
    assign clk_hs_en = done_w;
  end
  else begin: gen_clk_hs_en_hslp
    assign clk_hs_en = clk_hs_en_i;
  end
endgenerate 

csi2_4to1_1_tx_global_operation tx_global_operation_inst (
 ////added ports for handshaking with Rx/bridge/pixel2byte
  .clk_hs_en_i (clk_hs_en),
  .d_hs_en_i   (d_hs_en_i),
  .d_hs_rdy_o  (d_hs_rdy_o),

  // clock and reset
  .reset_n     (core_rstn),
  .core_clk    (core_clk_i),
  
  .dphy_pkten_i (dphy_pkten_w),
  .dphy_pkt_i   (dphy_pkt_w),

  // interface to DCI wrapper
  // HS i/f
  .hs_clk_gate_en_o (hs_clk_gate_en_w),
  .hs_clk_en_o      (hs_clk_en_w),
  .hs_data_en_o     (hs_data_en_w),
  .hs_data_d1_o     (hs_data_d1_w),
  .hs_data_d0_o     (hs_data_d0_w),

  .c2d_ready_o      (c2d_ready_w),
  
  // LP i/f
  .lp_clk_en_o      (lp_clk_en_w),
  .lp_clk_p_o       (lp_clk_p_w),
  .lp_clk_n_o       (lp_clk_n_w),
  .lp_data_en_o     (lp_data_en_w),
  .lp_data_p_o      (lp_data_p_w),
  .lp_data_n_o      (lp_data_n_w)
);

//-----------------------------------------------------------------
// Mixel DPHY instance
// Using HW model for now
//-----------------------------------------------------------------
wire lp_data_dcs_p_w;
wire lp_data_dcs_n_w;
wire dcs_lp_w;
wire dcs_ln_w;


assign lp_data_dcs_p_w = done_w ? lp_data_p_w : 1'b1;
assign lp_data_dcs_n_w = done_w ? lp_data_n_w : 1'b1;

///////////////////////////////////////////////////////////////
// dci_wrapper instance
///////////////////////////////////////////////////////////////
csi2_4to1_1_dci_wrapper dci_wrapper_inst   (
 // clock and reset
////separate refclk from pix_clk to add option to use Snow PLL
  .refclk          (ref_clk_i),
////change to reset for refclk
  .reset_n         (ref_rstn),
  
  // MIPI interface signals
  .clk_p_o         (clk_p_o),
  .clk_n_o         (clk_n_o),
  .d1_p_o          (d1_p_o),
  .d1_n_o          (d1_n_o),
  .d0_p_io         (d0_p_io),
  .d0_n_io         (d0_n_io),

  // high-speed transmit signals
  .txbyte_clkhs_o  (byte_clk_o),
  .pll_lock_o      (pll_lock_o),
  
  .txclk_hsen_i   (hs_clk_en_w & done_w), 
  .txclk_hsgate_i  (hs_clk_gate_en_w),
  .pd_dphy_i       (pd_dphy_i),

  .dl1_txdata_hs_i    (hs_data_d1_w),
  .dl0_txdata_hs_i    (hs_data_d0_w),
  .dl1_txdata_hs_en_i (hs_data_en_w & done_w),
  .dl0_txdata_hs_en_i (hs_data_en_w & done_w),

  // low-power transmit signals
  .txclk_lp_p_i       (done_w ? lp_clk_p_w : 1'b1),
  .txclk_lp_n_i       (done_w ? lp_clk_n_w : 1'b1),
  .clk_lpen_i         (done_w ? lp_clk_en_w : 1'b1),
  .lp_direction_i     (),

  .dl1_txdata_lp_p_i  (done_w ? lp_data_p_w : 1'b1),
  .dl1_txdata_lp_n_i  (done_w ? lp_data_n_w : 1'b1),
  .dl0_txdata_lp_p_i  (lp_data_dcs_p_w),
  .dl0_txdata_lp_n_i  (lp_data_dcs_n_w),
  
  .dl1_txdata_lp_en_i (done_w ? lp_data_en_w : 1'b1),
  .dl0_txdata_lp_en_i (done_w ? lp_data_en_w : 1'b1),

  // Not use - in case to support bus turn-around
  .rxclk_lp_p_o       (),
  .rxclk_lp_n_o       (),
  .dl0_rxdata_lp_p_o  (),
  .dl0_rxdata_lp_n_o  ()
);

// Used to mimic DCS Transaction for CSI interface
assign done_w = tinit_done_o;
//sig_delay sig_delay_inst(
//  .clk      (pix_clk_i),
//  .rstn     (pix_rstn),
//  .in       (pll_lock_o),
//  
//  .out      (done_w)
//);


  assign start_ptrn_gen = tinit_done_o;     // start when tinit_done_o is high

///////////////////////////////////////////////////////////////
// Tinit counter instance
///////////////////////////////////////////////////////////////
generate
if (TINIT_COUNT == "ON") begin: gen_tinit_count_on
  csi2_4to1_1_tinit_count tinit_count_inst(
    .clk          (core_clk_i),
    .resetn       (core_rstn),
    
    .tinit_done_o (tinit_done_o)
  );
end
else begin: gen_tinit_count_off
  assign tinit_done_o = pll_lock_o;
end
endgenerate

// For internal use only. Not used as a feature of the soft IP.

endmodule
